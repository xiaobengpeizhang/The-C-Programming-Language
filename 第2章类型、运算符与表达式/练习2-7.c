/**编写一个函数invert(x, p, n)，该函数返回对x执行下列操作后的结果值：将x中从第p位开始的n个（二进制）位求反（即1变成0，0变成1）x的其余各位保持不变**/

/*
 *分析，假设x（1101）p==n==2 1101->1011
 *x取反->0010 保留中间两位 0010 & 0110 -> 0010
 *x中间2位置0 1101 & 1001 -> 1001
 *1001来源 ~0(1111) << 2 -> ~(1100) -> 0011 << 1 -> ~0110 -> 1001 
 *0110来源 ~0(1111) << 2 -> ~1100 -> 0011 << 1 -> 0110
 * 1001 | 0010 = 1011
 */

 #include <stdio.h>

unsigned invert(x, p, n)
{
    return (x & (~(~(~0 << n) << p + 1 -n))) | ~x & ((~(~0 << n)) << p + 1 -n);
}



/*方法2 按位异或*/
/*
 *x(1101) ^ (0110)
 *0110得来：~0 -> 1111 <<2 -> ~1100 ->0011 << 1 -> 0110
 */
unsigned invert2(x, p, n)
{
    return x ^ ((~(~0 << n)) << p + 1 - n);
}

int main()
{
    printf("2进制1111(8+4+2+1==15)->1001(8+1==9) = %d\n", invert(15, 2, 2));
    printf("2进制1111(8+4+2+1==15)->1001(8+1==9) = %d\n", invert2(15, 2, 2));

}

