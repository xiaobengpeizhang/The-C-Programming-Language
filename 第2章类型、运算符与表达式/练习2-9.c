/**在求对二的补码时，表达式x&=(x-1)可以删除x中最右边值为1的一个二进制位。请解释这样做的道理。用这一方法重写bitcount函数，以加快其执行速度**/

/*
 *分析：x = x & (x - 1) -> 1101 & (1101 - 1) -> 1101 & (1100) -> 1100
 *1100 & (1011) -> 1000
 *原理非常简单
 *当减去1的时候，最右边的那位为1的位一定会变成0，从那位开始往左的不会变。往右的如果有0则全会变为1
 *这样当它 & 上自己原来的值时候，最右边为1的那一位左边全部保留，1那一位肯定置0. 1右边的那些 &运算后也还是0
 */

 /**重写bitcount函数，统计x中值为1的二进制位数**/
 /*
  *分析：循环检测x中最右边的值如果为1则消除直到全部检测完毕
  */

#include <stdio.h>

 int bitcount(unsigned x)
 {
    int b = 0;
    while (x != 0)
    {
        x &= x - 1;
        b++;
    }   
    return b;
 }

 int main()
 {
     printf("1101 == 8 + 4 + 2 == 14 (3) = %d\n", bitcount(14));
     return 0;
 }
